import sqlite3
import json
import hashlib
import socket
import uuid
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DatabaseManager:
    """数据库管理器，处理所有数据库操作"""
    
    def __init__(self, db_path: Optional[str] = None, auto_init: bool = False):
        if db_path is None:
            db_path = str(Path(__file__).parent.parent / 'database' / 'binary_manager.db')
        
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.conn = sqlite3.connect(str(self.db_path))
        self.conn.row_factory = sqlite3.Row
        
        self.publisher_id = self._get_or_create_publisher_id()
        
        if auto_init:
            self.init_database()
        
        logger.info(f"Database initialized: {self.db_path}")
        logger.info(f"Publisher ID: {self.publisher_id}")
    
    def _get_or_create_publisher_id(self) -> str:
        """获取或创建发布者ID"""
        hostname = socket.gethostname()
        
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT publisher_id FROM publishers WHERE hostname = ?', (hostname,))
            row = cursor.fetchone()
            
            if row:
                publisher_id = row['publisher_id']
                cursor.execute(
                    'UPDATE publishers SET last_active_at = ? WHERE publisher_id = ?',
                    (datetime.utcnow().isoformat(), publisher_id)
                )
            else:
                publisher_id = f"{uuid.uuid4()}@{hostname}"
                cursor.execute(
                    '''INSERT INTO publishers 
                       (publisher_id, hostname, first_seen_at, last_active_at, created_at, updated_at)
                       VALUES (?, ?, ?, ?, ?, ?)''',
                    (publisher_id, hostname, datetime.utcnow().isoformat(), 
                     datetime.utcnow().isoformat(), datetime.utcnow().isoformat(), 
                     datetime.utcnow().isoformat())
                )
            
            self.conn.commit()
            return publisher_id
        except sqlite3.OperationalError as e:
            if 'no such table' in str(e):
                publisher_id = f"{uuid.uuid4()}@{hostname}"
                logger.warning(f"Publishers table not found, using generated ID: {publisher_id}")
                return publisher_id
            raise
    
    def init_database(self, schema_path: Optional[str] = None):
        if schema_path is None:
            schema_path = str(Path(__file__).parent.parent / 'config' / 'database_schema.sql')
        
        with open(schema_path, 'r') as f:
            schema = f.read()
        
        self.conn.executescript(schema)
        self.conn.commit()
        logger.info("Database schema initialized")
    
    def save_package(self, package_info: Dict, git_info: Dict) -> Optional[int]:
        """保存包信息到数据库"""
        cursor = self.conn.cursor()
        
        now = datetime.utcnow().isoformat()
        
        try:
            cursor.execute('''
                INSERT INTO packages (
                    package_name, version, created_at, updated_at,
                    publisher_id, publisher_hostname,
                    git_commit_hash, git_commit_short, git_branch, git_tag,
                    git_author, git_author_email, git_commit_time, git_is_dirty,
                    archive_name, archive_size, archive_hash, file_count,
                    storage_type, storage_path, description, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                package_info['package_name'],
                package_info['version'],
                now, now,
                self.publisher_id,
                socket.gethostname(),
                git_info.get('commit_hash', ''),
                git_info.get('commit_short', ''),
                git_info.get('branch'),
                git_info.get('tag'),
                git_info.get('author', ''),
                git_info.get('author_email', ''),
                git_info.get('commit_time', ''),
                1 if git_info.get('is_dirty', False) else 0,
                package_info['file_info']['archive_name'],
                package_info['file_info']['size'],
                package_info['file_info']['hash'],
                package_info['file_info']['file_count'],
                package_info.get('storage', {}).get('type', 'local'),
                package_info.get('storage', {}).get('path', ''),
                package_info.get('description', ''),
                json.dumps(package_info.get('metadata', {}))
            ))
            
            package_id = cursor.lastrowid
            self.conn.commit()
            logger.info(f"Package saved with ID: {package_id}")
            return package_id
            
        except sqlite3.IntegrityError as e:
            logger.warning(f"Package already exists: {e}")
            cursor.execute('''
                SELECT id FROM packages 
                WHERE package_name = ? AND version = ? AND git_commit_hash = ?
            ''', (package_info['package_name'], package_info['version'], 
                   git_info.get('commit_hash', '')))
            row = cursor.fetchone()
            return row['id'] if row else None
    
    def create_group(self, group_info: Dict) -> Optional[int]:
        """创建Group"""
        cursor = self.conn.cursor()
        
        now = datetime.utcnow().isoformat()
        
        try:
            cursor.execute('''
                INSERT INTO groups (
                    group_name, version, created_at, updated_at,
                    created_by, description, environment_config, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                group_info['group_name'],
                group_info['version'],
                now, now,
                self.publisher_id,
                group_info.get('description', ''),
                json.dumps(group_info.get('environment_config', {})),
                json.dumps(group_info.get('metadata', {}))
            ))
            
            group_id = cursor.lastrowid
            self.conn.commit()
            logger.info(f"Group created with ID: {group_id}")
            return group_id
            
        except sqlite3.IntegrityError as e:
            logger.warning(f"Group already exists: {e}")
            cursor.execute('''
                SELECT id FROM groups WHERE group_name = ? AND version = ?
            ''', (group_info['group_name'], group_info['version']))
            row = cursor.fetchone()
            return row['id'] if row else None
    
    def add_package_to_group(self, group_id: int, package_id: int, 
                            install_order: int = 0, required: bool = True) -> None:
        """添加包到Group"""
        cursor = self.conn.cursor()
        
        try:
            cursor.execute('''
                INSERT INTO group_packages (group_id, package_id, install_order, required)
                VALUES (?, ?, ?, ?)
            ''', (group_id, package_id, install_order, 1 if required else 0))
            
            self.conn.commit()
            logger.info(f"Package {package_id} added to group {group_id}")
            
        except sqlite3.IntegrityError:
            cursor.execute('''
                UPDATE group_packages 
                SET install_order = ?, required = ?
                WHERE group_id = ? AND package_id = ?
            ''', (install_order, 1 if required else 0, group_id, package_id))
            self.conn.commit()
    
    def query_packages(self, filters: Optional[Dict] = None) -> List[Dict]:
        """查询包"""
        cursor = self.conn.cursor()
        
        query = 'SELECT * FROM packages WHERE 1=1'
        params = []
        
        if filters:
            if 'package_name' in filters:
                query += ' AND package_name = ?'
                params.append(filters['package_name'])
            
            if 'version' in filters:
                query += ' AND version = ?'
                params.append(filters['version'])
            
            if 'git_commit' in filters:
                query += ' AND git_commit_hash = ?'
                params.append(filters['git_commit'])
            
            if 'publisher_id' in filters:
                query += ' AND publisher_id = ?'
                params.append(filters['publisher_id'])
        
        query += ' ORDER BY created_at DESC'
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    def query_groups(self, filters: Optional[Dict] = None) -> List[Dict]:
        """查询Group"""
        cursor = self.conn.cursor()
        
        query = 'SELECT * FROM groups WHERE 1=1'
        params = []
        
        if filters:
            if 'group_name' in filters:
                query += ' AND group_name = ?'
                params.append(filters['group_name'])
            
            if 'version' in filters:
                query += ' AND version = ?'
                params.append(filters['version'])
            
            if 'created_by' in filters:
                query += ' AND created_by = ?'
                params.append(filters['created_by'])
        
        query += ' ORDER BY created_at DESC'
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    def get_group_packages(self, group_id: int) -> List[Dict]:
        """获取Group中的所有包"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT p.*, gp.install_order, gp.required
            FROM packages p
            INNER JOIN group_packages gp ON p.id = gp.package_id
            WHERE gp.group_id = ?
            ORDER BY gp.install_order, p.package_name
        ''', (group_id,))
        
        rows = cursor.fetchall()
        return [dict(row) for row in rows]
    
    def get_package_by_name_version(self, package_name: str, version: str) -> Optional[Dict]:
        """根据名称和版本获取包"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT * FROM packages 
            WHERE package_name = ? AND version = ?
            ORDER BY created_at DESC
            LIMIT 1
        ''', (package_name, version))
        
        row = cursor.fetchone()
        return dict(row) if row else None
    
    def add_dependency(self, group_id: int, package_id: int, 
                     depends_on_group_id: Optional[int] = None, depends_on_package_id: Optional[int] = None,
                     constraint_type: str = 'exact', version_constraint: Optional[str] = None) -> Optional[int]:
        """添加依赖关系"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            INSERT INTO dependencies (
                group_id, package_id, depends_on_group_id, 
                depends_on_package_id, constraint_type, version_constraint
            ) VALUES (?, ?, ?, ?, ?, ?)
        ''', (group_id, package_id, depends_on_group_id, 
               depends_on_package_id, constraint_type, version_constraint))
        
        dep_id = cursor.lastrowid
        self.conn.commit()
        logger.info(f"Dependency added with ID: {dep_id}")
        return dep_id
    
    def get_database_checksum(self) -> str:
        """计算数据库校验和"""
        cursor = self.conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        
        checksum = hashlib.md5()
        
        for table in tables:
            table_name = table[0]
            cursor.execute(f'SELECT * FROM {table_name}')
            rows = cursor.fetchall()
            checksum.update(json.dumps([dict(row) for row in rows]).encode())
        
        return checksum.hexdigest()
    
    def get_statistics(self) -> Dict:
        """获取数据库统计信息"""
        cursor = self.conn.cursor()
        
        stats = {}
        
        cursor.execute('SELECT COUNT(*) as count FROM packages')
        stats['total_packages'] = cursor.fetchone()['count']
        
        cursor.execute('SELECT COUNT(*) as count FROM groups')
        stats['total_groups'] = cursor.fetchone()['count']
        
        cursor.execute('SELECT COUNT(*) as count FROM publishers')
        stats['total_publishers'] = cursor.fetchone()['count']
        
        cursor.execute('SELECT SUM(archive_size) as total FROM packages')
        stats['total_storage_bytes'] = cursor.fetchone()['total'] or 0
        
        return stats
    
    def close(self):
        """关闭数据库连接"""
        if self.conn:
            self.conn.close()
            logger.info("Database connection closed")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


if __name__ == '__main__':
    import sys
    
    with DatabaseManager() as db:
        db.init_database()
        
        print(f"Publisher ID: {db.publisher_id}")
        print(f"Database: {db.db_path}")
        
        stats = db.get_statistics()
        print(f"Statistics: {json.dumps(stats, indent=2)}")
